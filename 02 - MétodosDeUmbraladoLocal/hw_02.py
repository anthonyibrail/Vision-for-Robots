# -*- coding: utf-8 -*-
"""HW-02.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1F1r-aeCD3kIJtIp7HRrdPYICKT5BB5rl

# **Métodos de umbrado local**
"""

import numpy as np                 # Trabaja con arreglos
import matplotlib.pyplot as plt    # Trabaja con visualización de información
import matplotlib.image as mpimg   # Trabaja con apertura/almacenamiento de imágenes
#from skimage.color import rgb2gray # Convierte la imagen de color a escala de grises
from skimage import color

# CONSTANTES
img = mpimg.imread(r'H01.bmp')
k = [0.2, 0.5]
R = 128
w = [15, 17]
c = [20, 30]

"""## Funciones de ayuda y chequeo de imagen"""

def show_props(image):  # Muestra propiedades de la imagen
  print("\nimg type: ", type(image))
  print("img shape: ", image.shape)
  print("img size: ", image.size)
  print("img min: ", image.min())
  print("img max: ", image.max())
  print("img mean: ", image.mean())

def show_img(image):    # Muestra imagen
  plt.figure()
  plt.imshow(image, cmap=plt.cm.gray, vmin=0, vmax=image.max())
  plt.axis('off')
  #plt.colorbar()

def check_img():  # Checa la imagen si es a color y lo cambia a grises, y lo reescala (0,1) a (0,255)
  global img
  if len(img.shape) > 2:
    show_props(img)
    print("\nSe convierte a escala de grises")
    img = 255*color.rgb2gray(img)

print("IMAGEN ORIGINAL")
show_props(img)
show_img(img)

check_img()
I = img
print("\nDespués de checar")
show_props(I)
show_img(I)

"""## Sauvola"""

def th_sauvola(I, k, R, w):
    rows, cols = I.shape
    
    # Crea una imagen en negro para almacenar los umbrales locales
    thresholded_image = np.zeros_like(I)
    
    # Calcula el tamaño de la ventana, sustituye al wh = int((w-1)/2)
    wh = w // 2
    
    # Recorre cada píxel de la imagen
    for i in range(wh, rows - wh):
        for j in range(wh, cols - wh):
            # Extrae la región de la imagen de tamaño w x w centrada en el píxel (i,j)
            window = I[i-wh : i+wh+1, j-wh : j+wh+1]
            
            # Calcula la media y la desviación estándar de la región
            mean = np.mean(window)
            stddev = np.std(window)
            
            # Calcula el umbral local para el píxel (i,j) utilizando la fórmula de Sauvola
            threshold = mean * ( 1 + k * ((stddev / R) - 1) )
            
            # Asigna un valor de blanco o negro al píxel (i,j) según el umbral local
            thresholded_image[i,j] = 255 if I[i,j] >= threshold else 0
    
    return thresholded_image

B1 = th_sauvola(I, k[0], R, w[0])
print("\nMétodo de umbralado local - Sauvola")
show_props(B1)
show_img(B1)
# Guardar la imagen procesada
plt.imsave('sauvola_thresh_output_1.jpg', B1, cmap=plt.cm.gray, vmin= B1.min(), vmax= B1.max() )

B2 = th_sauvola(I, k[1], R, w[0])
print("\nMétodo de umbralado local - Sauvola")
show_props(B2)
show_img(B2)
# Guardar la imagen procesada
plt.imsave('sauvola_thresh_output_2.jpg', B2, cmap=plt.cm.gray, vmin= B2.min(), vmax= B2.max() )

B3 = th_sauvola(I, k[0], R, w[1])
print("\nMétodo de umbralado local - Sauvola")
show_props(B3)
show_img(B3)
# Guardar la imagen procesada
plt.imsave('sauvola_thresh_output_3.jpg', B3, cmap=plt.cm.gray, vmin= B3.min(), vmax= B3.max() )

B4 = th_sauvola(I, k[1], R, w[1])
print("\nMétodo de umbralado local - Sauvola")
show_props(B4)
show_img(B4)
# Guardar la imagen procesada
plt.imsave('sauvola_thresh_output_4.jpg', B4, cmap=plt.cm.gray, vmin= B4.min(), vmax= B4.max() )

"""## Bernsen"""

def th_bernsen(I, w, c):
    global R
    # Obtener las dimensiones de la imagen
    rows, cols = I.shape

    # Inicializar la imagen binaria con todo en negro
    binary = np.zeros_like(I)

    # Calcula el tamaño de la ventana, sustituye al wh = int((w-1)/2)
    wh = w // 2

    # Inicializar la matriz para el valor del umbral óptimo con el mismo tamaño de la imagen de entrada
    optimal_threshold = np.zeros_like(I)

    # Iterar sobre la imagen
    for i in range(wh, rows-wh):
        for j in range(wh, cols-wh):
            # Obtener la región de la ventana
            window = I[i-wh : i+wh+1, j-wh : j+wh+1]
            # Obtener el valor máximo y mínimo de intensidad en la ventana
            max_val = np.max(window)
            min_val = np.min(window)
            # Calcular el contraste local
            contrast = max_val - min_val
            # Calcular el umbral
            threshold = int((max_val + min_val) / 2)

            if contrast <= c:
                threshold = R

            # Actualizar el valor del umbral óptimo en la matriz
            optimal_threshold[i,j] = threshold
                
            binary[i-wh : i+wh+1, j-wh : j+wh+1] = 255 if I[i, j] > threshold else 0
    # Calcular el umbral óptimo dividiendo la suma acumulada por el número total de píxeles
    optimal_threshold = optimal_threshold
    # Devolver la imagen binaria y el umbral óptimo
    return binary, optimal_threshold

BERN1, T = th_bernsen(I, w[0], c[0])
print("\nMétodo de umbralado local - Bersen")
print("Umbral óptimo: ", T)
# Guardar la matriz en un archivo de texto
np.savetxt("optimal_threshold1.txt", T, fmt='%d')
show_props(BERN1)
show_img(BERN1)
# Guardar la imagen procesada
plt.imsave('bernsen_thresh_output1.jpg', BERN1, cmap=plt.cm.gray, vmin=BERN1.min(), vmax=BERN1.max())

BERN2, T = th_bernsen(I, w[0], c[1])
print("\nMétodo de umbralado local - Bersen")
print("Umbral óptimo: ", T)
# Guardar la matriz en un archivo de texto
np.savetxt("optimal_threshold2.txt", T, fmt='%d')
show_props(BERN2)
show_img(BERN2)
# Guardar la imagen procesada
plt.imsave('bernsen_thresh_output2.jpg', BERN2, cmap=plt.cm.gray, vmin=BERN2.min(), vmax=BERN2.max())

BERN3, T = th_bernsen(I, w[1], c[0])
print("\nMétodo de umbralado local - Bersen")
print("Umbral óptimo: ", T)
# Guardar la matriz en un archivo de texto
np.savetxt("optimal_threshold3.txt", T, fmt='%d')
show_props(BERN3)
show_img(BERN3)
# Guardar la imagen procesada
plt.imsave('bernsen_thresh_output3.jpg', BERN3, cmap=plt.cm.gray, vmin=BERN3.min(), vmax=BERN3.max())

BERN4, T = th_bernsen(I, w[1], c[1])
print("\nMétodo de umbralado local - Bersen")
print("Umbral óptimo: ", T)
# Guardar la matriz en un archivo de texto
np.savetxt("optimal_threshold4.txt", T, fmt='%d')
show_props(BERN4)
show_img(BERN4)
# Guardar la imagen procesada
plt.imsave('bernsen_thresh_output4.jpg', BERN4, cmap=plt.cm.gray, vmin=BERN4.min(), vmax=BERN4.max())
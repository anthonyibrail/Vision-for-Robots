# -*- coding: utf-8 -*-
"""HW-01.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1s9TglOCiChP6snMZY5-VGXUVKyfuzH1f

Anthony Ibrail Ortega Méndez
Basado en: https://www.kaggle.com/code/thesherpafromalabama/manual-image-convolution-zero-padding
"""

import numpy as np                 # Trabaja con arreglos
import matplotlib.pyplot as plt    # Trabaja con visualización de información
import matplotlib.image as mpimg   # Trabaja con apertura/almacenamiento de imágenes
from skimage.color import rgb2gray # Convierte la imagen de color a escala de grises

# CONSTANTES
N = [3,5,9]
s = [1,4,8]
img = mpimg.imread(r'Thomas Bangalter.jpg')

def show_props(image):  # Muestra propiedades de la imagen
  print("\nimg type: ", type(image))
  print("img shape: ", image.shape)
  print("img size: ", image.size)
  print("img min: ", image.min())
  print("img max: ", image.max())
  print("img mean: ", image.mean())

def show_img(image):    # Muestra imagen
  plt.figure()
  plt.imshow(image, cmap=plt.cm.gray, vmin=0, vmax=image.max())
  plt.axis('off')
  #plt.colorbar()

print("IMAGEN ORIGINAL")
show_props(img)
show_img(img)

def check_img():  # Checa la imagen si es a color y lo cambia a grises, y lo reescala (0,1) a (0,255)
  global img
  if len(img.shape) > 2:
    print("\nSe convierte a escala de grises")
    img = rgb2gray(img)
    show_props(img)

  print(f'\nSCALE: {img.max()}')
  if img.max() < 255:
    rows = img.shape[0]
    cols = img.shape[1]
    for i in range(0, rows):
      for j in range(0, cols):
        img[i,j] = np.interp(img[i,j], (0,1), (0,255))

check_img()
print("\nDespués de checar")
show_props(img)
show_img(img)
plt.savefig('output_img0_original_checked.jpg')

def convolution(image, kernel):
    rows = image.shape[0]
    cols = image.shape[1]
    kernel_rows = kernel.shape[0]
    kernel_cols = kernel.shape[1]

    img_blur_thres = np.zeros_like(image) # Crea la salida con el tamaño de la imagen con puros ceros

    mask = np.zeros(( rows + (kernel_rows-1), cols + (kernel_cols-1) )) # Se crea la mask llenando el padding con ceros
    mask[(kernel_rows//2):-(kernel_rows//2), (kernel_cols//2):-(kernel_cols//2)] = image  # El operador doble barra // funciona como math.floor() sustituyendo el wh = int((w-1)/2) y se aplica el mask
    
    for i in range(rows):
        for j in range(cols):
            img_blur_thres[i,j] = np.median(kernel*mask[i:i + kernel_rows, j:j + kernel_cols]).sum() # Aplicando mask y obteniendo la media
    return img_blur_thres

def gausskernel(n, sigma): # Se realiza el kernel gaussiano recibiendo el tamaño del kernel y sigma junto a la desviación estándar
    cols = np.arange(-n, n+1, 1,)  # (start, stop, step)
    rows = np.arange(-n, n+1, 1)   # (start, stop, step)
    cols2d, rows2d = np.meshgrid(cols, rows)  # indexing
    # Desviación estándar
    kernel = (np.exp(-(cols2d ** 2 + rows2d ** 2) / (2 * sigma ** 2))) / (2 * np.pi * sigma ** 2)  
    return kernel

print("IMAGEN CHECADA")
show_props(img)
show_img(img)

print(f'\nIMAGEN 1 PROCESADA CON N = {N[0]} Y s = {s[0]}')
kernel = gausskernel(N[0], s[0])
img1 = convolution(img, kernel)
show_img(img1)
show_props(img1)
plt.savefig('output_img1.jpg')

print("IMAGEN CHECADA")
show_props(img)
show_img(img)

print(f'\nIMAGEN 2 PROCESADA CON N = {N[0]} Y s = {s[1]}')
kernel = gausskernel(N[0], s[1])
img2 = convolution(img, kernel)
show_img(img2)
show_props(img2)
plt.savefig('output_img2.jpg')

print("IMAGEN CHECADA")
show_props(img)
show_img(img)

print(f'\nIMAGEN 3 PROCESADA CON N = {N[0]} Y s = {s[2]}')
kernel = gausskernel(N[0], s[2])
img3 = convolution(img, kernel)
show_img(img3)
show_props(img3)
plt.savefig('output_img3.jpg')

print("IMAGEN CHECADA")
show_props(img)
show_img(img)

print(f'\nIMAGEN 4 PROCESADA CON N = {N[1]} Y s = {s[0]}')
kernel = gausskernel(N[1], s[0])
img4 = convolution(img, kernel)
show_img(img4)
show_props(img4)
plt.savefig('output_img4.jpg')

print("IMAGEN CHECADA")
show_props(img)
show_img(img)

print(f'\nIMAGEN 5 PROCESADA CON N = {N[1]} Y s = {s[1]}')
kernel = gausskernel(N[1], s[1])
img5 = convolution(img, kernel)
show_img(img5)
show_props(img5)
plt.savefig('output_img5.jpg')

print("IMAGEN CHECADA")
show_props(img)
show_img(img)

print(f'\nIMAGEN 6 PROCESADA CON N = {N[1]} Y s = {s[2]}')
kernel = gausskernel(N[1], s[2])
img6 = convolution(img, kernel)
show_img(img6)
show_props(img6)
plt.savefig('output_img6.jpg')

print("IMAGEN CHECADA")
show_props(img)
show_img(img)

print(f'\nIMAGEN 7 PROCESADA CON N = {N[2]} Y s = {s[0]}')
kernel = gausskernel(N[2], s[0])
img7 = convolution(img, kernel)
show_img(img7)
show_props(img7)
plt.savefig('output_img7.jpg')

print("IMAGEN CHECADA")
show_props(img)
show_img(img)

print(f'\nIMAGEN 8 PROCESADA CON N = {N[2]} Y s = {s[1]}')
kernel = gausskernel(N[2], s[1])
img8 = convolution(img, kernel)
show_img(img8)
show_props(img8)
plt.savefig('output_img8.jpg')

print("IMAGEN CHECADA")
show_props(img)
show_img(img)

print(f'\nIMAGEN 9 PROCESADA CON N = {N[2]} Y s = {s[2]}')
kernel = gausskernel(N[2], s[2])
img9 = convolution(img, kernel)
show_img(img9)
show_props(img9)
plt.savefig('output_img9.jpg')

def convolution_idkernel(image, kernel):
    w = 1
    rows = img.shape[0]
    cols = img.shape[1]
    kernel_rows = kernel.shape[0]
    kernel_cols = kernel.shape[1]

    img_blur_thres = np.zeros_like(image) # Crea la salida con el tamaño de la imagen con puros ceros
    
    mask = np.zeros(( rows + (kernel_rows-1), cols + (kernel_cols-1) )) # Se crea la mask llenando el padding con ceros
    mask[(kernel_rows//2):-(kernel_rows//2), (kernel_cols//2):-(kernel_cols//2)] = image  # El operador doble barra // funciona como math.floor() sustituyendo el wh = int((w-1)/2) y se aplica el mask
    
    for i in range(rows):
        for j in range(cols):
            for m in range(-w,w):
                for l in range(-w,w):
                    img_blur_thres[i,j] = (kernel*mask[i:i + kernel_rows, j:j + kernel_cols]).sum() # Aplicando mask
    return img_blur_thres

id_kernel1 = np.array([[1,1,1],
                      [0,0,0],
                      [-1,-1,-1]])

img10 = convolution_idkernel(img,id_kernel1)
show_img(img10)
show_props(img10)
plt.savefig('output_img10.jpg')

id_kernel2 = np.array([[1,0,-1],
                      [1,0,-1],
                      [1,0,-1]])

img11 = convolution_idkernel(img,id_kernel2)
show_img(img11)
show_props(img11)
plt.savefig('output_img11.jpg')